/*******************
 * This code requires the PCF8814 library found here:
 * https://github.com/cattzalin/Arduino-library-nokia-1100-lcd--PCF8814
 */

// IMPORT PCF8814 LIBRARY (USE LINK ABOVE)
#include <PCF8814.h>

// Serial ----------------------------------------
  const long SERIAL_BAULRATE = 115200; // By Default baulrate for Bluetooth (HC05) is 9600, so if you didn't change it set that one

// LCD ----------------------------------------

// PINS to Arduino
  const byte ledPin = 8; // backlight
  const byte slckPin = 13; // clock
  const byte resetPin = 7; // reset
  const byte scePin = 12; // enable
  const byte sdinPin = 11; // data-in (PWM~)

// Screen Size
  const byte LCD_WIDTH = 96;
  const byte LCD_HEIGHT = 65;

// Create an instance of the LCD
  PCF8814 lcd(slckPin, sdinPin, resetPin, scePin);

// WHEELS -------------------------------------

// PINS to Arduino (PWM~)
  const byte leftA = 5; // Left Motor +
  const byte leftB = 6; // Left Motor -
  const byte rightA = 9; // Right Motor +
  const byte rightB = 10; // Right Motor -


// BITMAPS --------------------------------------

 const byte splash [] = {
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0xfc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f,
  0xff, 0x80, 0x0, 0x1f, 0xf0, 0x0, 0x0, 0x7f, 0xff, 0xc0, 0x0, 0xff, 0xfe, 0x0, 0x0,
  0xff, 0xff, 0xe0, 0x1, 0xff, 0xff, 0x0, 0x3, 0xff, 0xff, 0xf0, 0x7, 0xff, 0xff, 0x80,
  0x7, 0xff, 0xff, 0xf8, 0x7, 0xff, 0xff, 0xc0, 0x7, 0xff, 0xff, 0xf8, 0xf, 0xff, 0xff,
  0xe0, 0x7, 0xff, 0xff, 0xfc, 0xf, 0xff, 0xff, 0xe0, 0x7, 0xff, 0xff, 0xfc, 0x1f, 0xff,
  0xff, 0xf0, 0x7, 0xff, 0xff, 0xfc, 0x1f, 0xff, 0xff, 0xf0, 0x7, 0xff, 0xfe, 0x3c, 0x1f,
  0xff, 0xff, 0xf0, 0x7, 0xff, 0xfe, 0x3c, 0x1e, 0xff, 0xfc, 0xf0, 0x7, 0xff, 0xfc, 0x3c,
  0x1e, 0xff, 0xf0, 0xf0, 0x7, 0xff, 0xfc, 0x7c, 0x1e, 0xff, 0xf0, 0xf0, 0x7, 0xdf, 0xf0,
  0x7c, 0x1e, 0x7f, 0xf0, 0xf0, 0x7, 0xff, 0xf0, 0xfc, 0x1f, 0x3f, 0xf1, 0xf0, 0x3, 0xff,
  0xc1, 0xf8, 0x1f, 0x3f, 0xf1, 0xf0, 0x3, 0xf8, 0x3, 0xf8, 0x1f, 0xbf, 0xf3, 0xf0, 0x1,
  0xff, 0x1f, 0xf0, 0xf, 0xc0, 0x7, 0xe0, 0x0, 0xff, 0xff, 0xe0, 0xf, 0xe0, 0xf, 0xe0,
  0x0, 0x7f, 0xff, 0xc0, 0x7, 0xfc, 0x7f, 0xc0, 0x0, 0x3f, 0xff, 0x80, 0x3, 0xff, 0xff,
  0x80, 0x0, 0x7, 0xfc, 0x0, 0x1, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff,
  0xfe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1f,
  0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xf0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x7c, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x78, 0x78, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x7c, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xf8, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x7f, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3f, 0xf0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x1f, 0xe0, 0x7f, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f,
  0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7f, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x7f, 0xff, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x1, 0xff,
  0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x1,
  0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x1, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0,
  0x1, 0xff, 0xff, 0xff, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
  0x0, 0x0
};

// Bluetooth Actions ---------------------------------------
static const int BT_INPUT_SIZE = 50; // Max length for read chunks from bluetooth serial

void stopMotors() {
  analogWrite(rightA, 0);
  analogWrite(leftA, 0); 
  analogWrite(rightB, 0);
  analogWrite(leftB, 0); 
  delay(500);
}

void moveForward(int vel, int time) {
  analogWrite(rightA, vel);  
  analogWrite(leftA, vel); 
  delay(time);
  stopMotors();
}

void moveBackwars(int vel, int time) {
  analogWrite(rightB, vel);  
  analogWrite(leftB, vel); 
  delay(time);
  stopMotors();
}

// LCD Backlight Timer -------------------------------------

int backLight_ONby = 0; // how many secs to be on
long backLight_snapshotON = 0; // started milli-secs

void backlight_ON(int time = 20) {
  digitalWrite(ledPin, HIGH);
  backLight_snapshotON = millis();
  backLight_ONby = time*1000;
}

void backlight_loop() {
  if(backLight_ONby > 0 && (millis() - backLight_snapshotON  > backLight_ONby)){
    digitalWrite(ledPin, LOW);
    backLight_ONby = 0;
    backLight_snapshotON = 0;
  }
}

void showTextLCD(int line, int col, String text){
  backlight_ON(10);
  lcd.setCursor(line,col);
  lcd.clearLine();
  lcd.print(text);
}

void drawImageLCD(int line, int col, int image, byte width = 64, byte height = 64) {
  backlight_ON(10);
  lcd.setCursor(line,col); 
  lcd.clear();
  
  const byte* img;
  switch(image){ // Image CODE 
    case 0: img = splash; break;
  }
  
  lcd.drawBitmap(img, width, height);
}

void fireAction(int type, int value) {
  
  //lcd.clear();
  showTextLCD(2, 2, "T: " + String(type) + " V: " + String(value));

  if (type >= 10 && type < 50) { // Display
    switch (type) {
      case 11: // Show Image
        // TODO: add images
        //lcd.clear(); // For Test
        //showTextLCD(0, 0, "Got a value of " + String(value));
      break; 
    }    
  }
  else if (type >= 50 && type < 100) { // Move
    stopMotors(); // Stop before move

    switch (type) {
      case 60: // Move Forward
        moveForward(value, 2000);
      break; 
      case 70: // Move Backwards
        moveBackwars(value, 2000);
      break; 
    }    
  }
 
}

void bluetooth_loop() {
  while(Serial.available() > 0) {

    char input[BT_INPUT_SIZE + 1];
    // Get next command from Serial (add 1 for final 0)
    byte size = Serial.readBytes(input, BT_INPUT_SIZE);
    input[size] = 0; // Add the final 0 to end the C string

    // Read each command pair 
    char* command = strtok(input, "&"); // & is the command separator
    
    while (command != 0) {
      // Split the command in two values
      char* separator = strchr(command, ':');
      if (separator != 0) {
        // string splitted into X: replace ':' with 0
        *separator = 0;
        int type = atoi(command);
        
        ++separator;
        int value = atoi(separator);
        
        fireAction(type, value);
      }
      
      // Find the next command in input string
      command = strtok(0, "&");
    }

  }
}

void setup() {

  //START A SERIAL SESSION
  Serial.begin(SERIAL_BAULRATE);

  //INITIALIZE THE LCD
  lcd.begin(LCD_WIDTH, LCD_HEIGHT);
  lcd.clear();

  //INITIALIZE THE ARDUINO PINS FOR INPUT/OUTPUT
  pinMode(ledPin, OUTPUT);
  pinMode(leftA, OUTPUT);
  pinMode(leftB, OUTPUT);
  pinMode(rightA, OUTPUT);
  pinMode(rightB, OUTPUT);

  //TURN ON THE LCD AND SHOW SPLASH
  drawImageLCD(10, 0, 0, 64, 64);
  delay(2000);
  lcd.clear();
}

void loop() {
  bluetooth_loop();
  backlight_loop();
}
